// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

// Definitions for Cloud Crypto SDK (Tink) library.
syntax = "proto3";

package google.cloud.crypto.tink;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

option java_package = "com.google.cloud.crypto.tink";
option java_outer_classname = "TinkProto";

// Each instantiation of a Tink primitive is identified by key_type,
// which is a global URL pointing to a *Key proto that holds key material
// and other parameters of the instantiation. For each key_type, in addition
// to the *Key proto, there exist two related structures:
//   1. *Params: parameters of an instantiation of the primitive,
//      needed when a key is being used.
//   2. *KeyFormat: parameters needed to generate a new key; these
//      include the corresponding Params, since when a factory generates
//      a key based on KeyFormat, it must add Params to the resulting
//      key proto with the actual key material.
// The actual *KeyFormat proto is wrapped in a KeyFormat message.
message KeyFormat {
  string key_type = 1;
  google.protobuf.Any format = 2;  // Contains specific *KeyFormat proto.
}

// Each *Key proto by convention contains a version field, which
// identifies the version of implementation that can work with this key.
//   message SomeInstantiationKey {
//     uint32 version = 1;
//     ...
//   }
// Version is a monotonic counter: each implementation of a primitive
// has its associated "current version", which starts at 0 and is incremented
// upon updates of the code/key proto.  A key with version n needs
// an implementation version n or higher to work.

// For public key primitives, the public and private keys are distinct entities
// and represent distinct primitives.  However, by convention, the private key
// of a public-key primitive contains the corresponding public key proto.

// TODO(przydatek): consider following convention:
//     If the key_type does not need parameters then it should
//     be possible to skip the format buffer.
//     If the key_type does have parameters then we should make the
//     format required.

// A Tink user works usually not with single keys, but with keysets,
// to enable key rotation.  The keys in a keyset can belong to different
// implementations/key types, but must all implement the same primitive.
// Any given keyset (and any given key) can be used for one primitive only.
message Keyset {
  message Key {
    // Contains the actual, instantiation specific key proto.
    // By convention, each key proto contains a version field.
    google.protobuf.Any key_data = 1;

    enum StatusType {
      UNKNOWN_STATUS = 0;
      ENABLED = 1;    // Can be used for crypto operations.
      DISABLED = 2;   // Cannot be used, but exists and can become ENABLED.
      DESTROYED = 3;  // Key data does not exist in this Keyset any more.
    }
    StatusType status = 2;

    // Identifies a key within a keyset, is a part of metadata
    // of a ciphertext/signature.
    int32 key_id = 3;

    // Tink produces and accepts ciphertexts or signatures that consist
    // of a prefix and a payload. The payload and its format is determined
    // entirely by the primitive, but the prefix has to be one of the following
    // 3 types:
    //   - Legacy: prefix is 5 bytes, starts with \x00 and followed by a 4-byte
    //             key id.
    //   - Tink  : prefix is 5 bytes, starts with \x01 and followed by a 4-byte
    //             key id.
    //   - Raw   : prefix is 0 byte, i.e., empty.
    enum PrefixType {
      UNKNOWN_PREFIX = 0;
      TINK = 1;
      LEGACY = 2;
      RAW = 3;
    }
    PrefixType prefix_type = 4;

    // Note: info for key management is still work-in-progress.
    // TODO(przydatek): update this proto once key management is stable.
    // Optional fields, used by key management tools, but not used
    // by actual cryptographic operations.
    google.protobuf.Timestamp generated_at = 101;
    google.protobuf.Timestamp valid_until = 102;
  }

  // Provides the parameters necessary to generate a new key.
  // TODO(przydatek): consider keeping the format outside of a keyset.
  // Required.
  KeyFormat key_format = 2;

  // Identifies key used to generate new crypto data (encrypt, sign).
  // Required.
  int32 primary_key_id = 3;

  // Actual keys in the Keyset.
  // Required.
  repeated Key key = 4;
}

// Represents a keyset that is encrypted with a key in a KMS.
// The library assumes that the KMS key implements the Aead interface.
message KmsEncryptedKeyset {
  // Required.
  google.protobuf.Any kms_key = 1;
  // Required.
  bytes key_material = 2;
  // Optional.
  // This protobuf doesn't contain any key material, and is used for
  // documentation purpose only.

  // TODO(thaidn): introduce a "KeysetInfo"-proto, that is a "safe" subset
  // of Keyset-proto and is for logging/monitoring only.
  Keyset keyset = 3;
}
